# quickstream(1) completion
@GEN_FILE@

# REFERENCES:
#
# https://unix.stackexchange.com/questions/151118/understand-compgen-builtin-command
# https://debian-administration.org/article/317/An_introduction_to_bash_completion_part_2

_quickstream()
{
    local cur prev opts map
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="@OPTS@"

    # COMPREPLY is the global array of possible completions

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi

    if [[ ${prev} != -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi

    if [[ ${prev} == -* ]] ; then
        # See is prev is an option that has no argument.
        declare -A map=(@OPTS_NOARG@)
        if [[ ${map["${prev}"]} ]] ; then
            # prev is an option with no ARG so we can only
            # have, -*, an option flag next.
            COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
            return 0
        fi
    fi

    local modtype;

    case "${prev}" in

        -c|--connect)
            COMPREPLY=( ""
            "filter indexes like \"0 1\" or none for all loaded"
            )
            return 0
            ;;

        -p|--plug)
            COMPREPLY=( ""
            "filter indexes and ports like \"0 1 3 4\""
            )
            return 0
            ;;

        -f|--filter|-F|--filter-help)
            # We'll get a list of filters below
            modtype=filters
            ;;
        # TODO: add module type controllers??

        -t|--threads)
            # This is a nice hack:  Print a hint for the user in a
            # otherwise broken COMPREPLY array.
            COMPREPLY=( "Enter the number of worker threads" "" )
            return 0
            ;;
        *)
            # Here we are done with all the non-filter list ARGS:
            return 0
            ;;
    esac

    # All that is left is to get a list of filter modules by
    # looking for them in the file system.  The files paths are relative
    # to this file or from an environment variable PATH.

    #COMPREPLY=( "-- This is a list of filters --" "" )


    local mod_dir="$(dirname ${BASH_SOURCE[0]})" || return 0 # bash failed


    # TODO: For now we require that this bash file be in a special path
    # directory which is requires that filter plugins be in
    # ../../share/crts/plugins/Filters/ relative to the directory this
    # file is in.
    #
    # This will even work when the software is not installed yet and is
    # built in the source directory.  A major major plus for developers.

    local mod_dirs=($mod_dir/../../../lib/quickstream/plugins/$modtype/)
    local dirs
    local d

    # Now add modules from the environment variable QS_MODULE_PATH
    if [ -n "$QS_MODULE_PATH" ] ; then
        IFS=':' read -r -a dirs <<< "$QS_MODULE_PATH"
        for d in $dirs ; do
            #echo "d=$d/$modtype"
            mod_dirs+=($d/$modtype/)
        done
        #echo -e "\n\n   mod_dirs=${mod_dirs[@]}\n\n"
    fi

    mod_dirs+=($PWD/$modtype)
    #echo "mod_dirs[]= ${mod_dirs[@]}"

    local i
    local mod
    local mods=()

    for mod_dir in ${mod_dirs[@]} ; do
        for i in $mod_dir/*.so ; do
            if [ ! -f "$i" ] ; then
                continue
            fi
            mod="$(basename ${i%%.so})" || return 0
            mods+=($mod)
            #echo "mod=${mod}"
        done
        for i in $mod_dir/*/*.so ; do
            if [ ! -f "$i" ] ; then
                continue
            fi
            mod="$(basename $(dirname $i))/$(basename ${i%%.so})" || return 0
            mods+=($mod)
            #echo "mod=${mod}"
        done
    done

    opts=
    for i in "${mods[@]}" ; do
        if [[ "$i" = "${cur_word}"* ]] ; then
            opts="${opts} $i"
        fi
    done

    COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )

    return 0
}

complete -F _quickstream quickstream

# ex: filetype=sh
