#ifndef __qsapp_h__
#define __qsapp_h__

#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>

/** \file
 *
 * The libquickstream application programming interface (API)
 *
 * You can link your C and C++ code with the libquickstrean library to
 * make quickstream programs that load quickstream filter modules,
 * assemble these filters into flow graphs, and run the flow graphs.
 *
 * You can do the same with the program \ref quickstream_program.
 *
 *
 * The following terms are used in function names:
 *
 * API objects
 *
 * - **Qs app**     a collection of loaded filter module plugins,
 *                  a collection of streams
 *                  an application container for all that is quickstream
 *
 * - **Qs stream**  a directed graph of filters,
 *                  a mapping of filters to threads,
 *                  a mapping of threads to processes, and
 *                  an interface to run the stream
 *
 * - **Qs filter**  a filter module plugin from a dynamic shared object
 *                  file
 *
 * - **Qs process** an operating system process
 *
 * - **Qs thread**  an operating system thread (pthread)
 *
 */ 


/** quickstream release version number
 *
 * This release version number is not necessarily the same as library
 * version numbers.
 */
// Change this QS_VERSION macro string to make a new version.
#define QS_VERSION "@PACKAGE_VERSION@"

/** Read the last quickstream error string
 *
 * Calling this function also clears the current error.  This interface is
 * defective, in that new errors in other threads may overwrite the
 * internal error string before it can be read with this, or by any
 * other thread.  Per-thread error strings create other issues.
 *
 * To clear the current error, if there is one or not, call
 * qsError().  This can be called without checking if there is an
 * error or not.
 *
 * \return a pointer to a string, or 0 if there is no error.  The
 * memory for the string is managed by the qsError() function.
 *
 *  \todo add error return int values that correspond to strings.
 */
extern
const char *qsError(void);


/** Create the highest level quickstream construct,
 * a quickstream app.
 *
 * \return a pointer to an app structure, or 0 on failure*/
extern
struct QsApp *qsAppCreate(void);


extern
int qsAppDestroy(struct QsApp *app);


/** Add a filter module to the list of filter modules to be loaded.
 *
 * If the filter is successfully loaded and a construct symbol is found
 * the construct will be called as a function with some arguments.  See
 * \ref construct().
 *
 * \param app that was returned from a call to qsAppCreate().
 * \param fileName that refers to the plugin module file.
 * \param loadName a made-up unquie name that was refer to this
 * loaded plugin module.  loadName=0 maybe passed in to have the
 * name generated based on fileName.
 *
 * \return 0 on success.
 *
 * \see qsFilterUnload().
 */
extern
struct QsFilter *qsAppFilterLoad(struct QsApp *app,
        const char *fileName,
        const char *loadName,
        int argc, const char **argv);


/** Print the help for the filter module
 *
 */
extern
int qsFilterPrintHelp(const char *filterName, FILE *f);


enum QsAppPrintLevel {
    QsPrintOutline = 0,
    QsPrintDefault = 0,
    QsPrintDebug = 3
};


extern
int qsAppPrintDotToFile(struct QsApp *app, enum QsAppPrintLevel l,
        FILE *file);

/**
 *
 *
 * \param waitForDisplay if set this will not return until the
 * display program exits.
 *
 * \return 0 on success.
 */
extern
int qsAppDisplayFlowImage(struct QsApp *app, enum QsAppPrintLevel l,
        bool waitForDisplay);


extern
int qsFilterUnload(struct QsFilter *filter);


extern
struct QsStream *qsAppStreamCreate(struct QsApp *app);


/** allow or disallow loops in the stream\
 *
 * By default the stream does not allow loops in the filter stream graph.
 *
 * \param stream is the stream that we are allowing or disallowing loops
 * in.
 *
 * \param doAllow Pass the doAllow value of true to set allowing loops in
 * the stream graph.  Pass in doAllow value of false to not allow loops in the
 * stream graph.
 */
extern
void qsStreamAllowLoops(struct QsStream *stream, bool doAllow);

extern
int qsStreamDestroy(struct QsStream *stream);

/** Remove a filter and it's connections from a stream
 *
 * This does not unload the filter module plugin.
 *
 * \return 0 if the filter was found and removed, and non-zero otherwise.
 */
extern
int qsStreamRemoveFilter(struct QsStream *stream, struct QsFilter *filter);

extern
int qsStreamConnectFilters(struct QsStream *stream,
        struct QsFilter *from, struct QsFilter *to);



// TODO: We we don't have stream start and stop functions make there just
// be a qsStreamRun().


/** Start the flow
 *
 * Launches threads and calls the filter callbacks ... bla bla.
 *
 * When properly run, qsStreamStop() will be called after this.
 *
 * If you calling qsStreamStart() after a failed call to
 * qsStreamPrestart() will cause qsStreamPrestart() to be called again,
 * and it will likely fail again.
 *
 * \param stream the stream object that has the filters that are
 * connected.
 *
 * \return 0 if the stream runs and non-zero on error.
 */
extern
int qsStreamStart(struct QsStream *stream);


/** Prestart the flow
 *
 * Allocate resources for the stream to flow.
 *
 * qsStreamStart() will call qsStreamPrestart() if the user does not call
 * qsStreamPrestart() before  qsStreamStart().  qsStreamPrestart() will
 * setup the resources needed to start the stream flow, but it will not
 * start the flow.  This qsStreamPrestart() may be helpful to debugging
 * your stream.  One could call qsAppDisplayFlowImage() after a call to
 * qsStreamPrestart() to have a look at the streams while they are setup,
 * but before they are running.  You can call qsAppDisplayFlowImage()
 * after the stream is running, but calling qsStreamPrestart() and then
 * qsAppDisplayFlowImage() will produce the same image without running the
 * stream.
 *
 * \param stream the stream object that has the filters that are
 * connected.
 *
 * \return 0 if the stream runs and non-zero on error.
 */
extern
int qsStreamPrestart(struct QsStream *stream);



/** Stop the flow
 *
 * For a given stream qsStreamStop() be called after qsStreamStart().
 *
 */
extern
int qsStreamStop(struct QsStream *stream);



/** Create a thread object
 *
 * This does not start the thread.  It just sets up what threads
 * will be used when the stream runs.  See \ref qsStreamStart() and
 * qsStreamStop().
 *
 * \param stream returned from qsAppStreamCreate().
 *
 * \return a pointer to a thread object, or 0 on failure.
 */
extern
struct QsThread *qsStreamThreadCreate(struct QsStream *stream);


extern
int qsThreadDestroy(struct QsThread *thread);


extern
int qsThreadAddFilter(struct QsThread *thread, struct QsFilter *filter);



#endif // #ifndef __qsapp_h__
